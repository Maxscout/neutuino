use std::ffi::{c_int, c_uint, c_ulong, c_ushort};
use std::io;
use std::mem;

unsafe extern "C" {
    fn isatty(fd: c_int) -> c_int;
    fn ioctl(fd: c_int, request: c_ulong, argp: *mut u8) -> c_int;
    fn tcgetattr(fd: c_int, termios_p: *mut Termios) -> c_int;
    fn tcsetattr(fd: c_int, optional_actions: c_int, termios: *mut Termios) -> c_int;
    fn cfmakeraw(termios: *mut Termios);
}

#[cfg(target_os = "linux")]
const TIOCGWINSZ: c_ulong = 0x5413;

#[cfg(any(target_os = "macos", target_os = "freebsd"))]
const TIOCGWINSZ: c_ulong = 0x40087468;

#[cfg(target_os = "linux")]
const NCCS: usize = 32;

#[cfg(any(target_os = "macos", target_os = "freebsd"))]
const NCCS: usize = 20;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
struct Winsize {
    row: c_ushort,
    col: c_ushort,
    xpixel: c_ushort,
    ypixel: c_ushort,
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct Termios {
    iflag: c_uint,
    oflag: c_uint,
    cflag: c_uint,
    lflag: c_uint,
    cc: [u8; NCCS],
}

#[derive(Debug, Clone)]
pub struct RawTerminal {
    input: Termios,
    output: Termios,
}

impl RawTerminal {
    pub fn new() -> io::Result<RawTerminal> {
        let mut term: RawTerminal = unsafe { mem::zeroed() };
        if unsafe { tcgetattr(0, &raw mut term.input) } != 0 {
            return Err(io::Error::last_os_error())
        }
        if unsafe { tcgetattr(1, &raw mut term.output) } != 0 {
            return Err(io::Error::last_os_error())
        }
        let orig_term = term.clone();
        unsafe { cfmakeraw(&raw mut term.input) };
        unsafe { cfmakeraw(&raw mut term.output) };
        if unsafe { tcsetattr(0, 0, &raw mut term.input) } != 0 {
            return Err(io::Error::last_os_error())
        }
        if unsafe { tcsetattr(1, 0, &raw mut term.output) } != 0 {
            return Err(io::Error::last_os_error())
        }
        Ok(orig_term)
    }
}

impl Drop for RawTerminal {
    fn drop(&mut self) {
        unsafe { tcsetattr(0, 0, &raw mut self.input) };
        unsafe { tcsetattr(1, 0, &raw mut self.input) };
    }
}

pub fn istty() -> bool {
    unsafe { isatty(1) != 0 }
}

pub fn get_terminal_size() -> io::Result<(c_ushort, c_ushort)> {
    let mut winsize = unsafe { std::mem::zeroed::<Winsize>() };
    let ioctl_result = unsafe { ioctl(1, TIOCGWINSZ, &raw mut winsize as *mut u8) };

    if ioctl_result == 0 {
        Ok((winsize.col, winsize.row))
    } else {
        Err(io::Error::last_os_error())
    }
}

pub fn enable_ansi() -> io::Result<()> {
    // ANSI is on by default on unix platforms
    // This is here for compatibility with the windows version of this API
    Ok(())
}
